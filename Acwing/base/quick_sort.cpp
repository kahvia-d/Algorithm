//
// Created by Kahiva on 2024/1/4.
//
#include <iostream>

using namespace std;

const int N = 100010;
int t[N];

void quick_sort(int l, int r){
    if(l >= r) return;
    int i = l - 1, j = r + 1, x = t[(l + r) / 2];

    while(i < j){
        //基准值元素也可以交换，在左区间或者右区间都可以，因此while (t[i] < x);没有等号=。
        //如果是不能交换，即while (t[i] <= x);
        //那么比如6 2 3，基准值为2时。从左边找到了一个比2大的值6，但是从右边找不到比2小的，j--会一直执行，死循环了。
        do i++; while (t[i] < x);
        do j--; while (t[j] > x);
        if(i < j) swap(t[i],t[j]);
    }

    /*在划分区间递归调用快排的时候，i==j或者i>j
     ①当i==j时，举例数组为2 1. l==0，r==1。区间为[0,1]。
        x = t[(l + r) / 2];取值为x=2，相当于取数组首元素为基准值，经过循环后i==j==0。
        正确的分法：划分区间应为[0,0]和[1,1]，即[l, j]和[j + 1, r]，或者将j换成i。
        也就是将相遇处的元素划分给右区间。
        错误的分法：如果划分给左区间，即[l, j - 1]和[j, r]的话，区间为[0,-1]和[0,1]。
        右区间的快排与当前快排区间相同，导致右区间递归与当前相同，陷入死循环。
        若想使得该分法正确，应当x = t[(l + r + 1) / 2]，即取数组尾元素为基准值。
     ②当i>j时。举例，在上一轮while中交换ij元素后，进入下一轮while循环前，
        i == 1, j == 2，进入循环后，i++变成2，j--变成1，此时发生i > j的情况。且<2的元素<=x, >1的元素>=x。
        这种情况下划分区间时，根据①的两种分法，为了保证划分的正确性:
        若取数组首元素为基准值，则应采用j,即[l, j]和[j + 1, r]。
        如果采用[l, i]和[i + 1, r]，右区间为[3, r]很显然缺少了下标2对应的>=x的元素，同理左区间会多一个。
        若取数组尾元素为基准值，则应采用i,即[l, i - 1]和[i, r]。原理同上。

     总结：一整个快速排序中包含很多个小快速排序，可能出现i==j和i>j的情况。因此，为了确保两种情况下都正常运行，分类如下。
     ①x = t[(l + r) / 2];或者说取左端点元素为基准值的情况下，递归区间划分[l, j]和[j + 1, r]。
     ②x = t[(l + r + 1) / 2]；或者说取右端点元素为基准值的情况下，递归区间划分[l, i - 1]和[i, r]。
     */
    quick_sort(l,j);
    quick_sort(j + 1,r);
}

int main(){
    int n;
    scanf("%d",&n);

    for(int i = 0; i < n; i++)
        scanf("%d",&t[i]);

    quick_sort(0, n - 1);

    for(int i = 0; i < n; i++)
        printf("%d ",t[i]);
    return 0;
}